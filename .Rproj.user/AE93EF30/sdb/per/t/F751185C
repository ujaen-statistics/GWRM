{
    "contents" : "#' Extract and Visualize Model Residuals\n#'\n#' residuals is a method which extracts model residuals from \"gw\", commonly returned\n#' by gw function. Optionally, it produces a normal plot with simulated envelope of the residual.\n#'\n#' @param object\tobject of class \"gw\" holding the fitted model\n#' @param type type of residuals to be extracted. Default is pearson. response and deviance are also available.\n#' @param rep\tnumber of replications for envelope construction. Default is 19, that is the smallest 95 percent band that can be build\n#' @param envelope\ta logical value to specify if the envelope is required.\n#' @param title\ta title for the envelope.\n#' @param trace\tif TRUE a sort of information is printed during the running time.\n#' @param parallel if TRUE use parallel executation\n#' @param ncores is the number of cores that we use if parallel is TRUE\n#' @param ... \tfurther arguments passed to or from other methods.\n#'\n#' @return residuals values and plot\n#'\n#' @examples\n#' data(goals)\n#' fit0 <- gw(goals ~ position, data = goals)\n#' residuals(fit0, type = \"pearson\", rep = 19, envelope = TRUE, trace = FALSE, ncores=2)\n#'\n#' @importFrom stats qnorm\n#' @importFrom graphics lines plot polygon\n#' @importFrom doParallel registerDoParallel\n#' @importFrom parallel makeCluster stopCluster clusterExport detectCores\n#' @importFrom foreach foreach %dopar% %do%\n#' @export\n\nresiduals.gw <- function(object, type = \"pearson\", rep = 19, envelope = TRUE, title = \"Simulated Envelope of Residuals\", trace = FALSE, parallel=TRUE, ncores=2,  ...){\n\n  resid.gw <- function(object, type){\n    mu <- object$fitted.values\n    k <- object$betaIIpars[1]\n    ro <- object$betaIIpars[2]\n    if (type == 'pearson'){\n      if (ro < 2) stop('Variance is infinite')\n      else{\n        varianza <- ((k + ro - 1) / (ro - 2)) * (mu + (mu ^ 2) / k)\n        residuos <- sort(object$residuals / sqrt(varianza))\n        return(residuos)\n      }\n    }\n    if (type == 'deviance'){\n      a <- mu * (ro - 1) / k\n      gama <- a + k + ro\n      y <- object$Y\n      residuos <- sort(2 * (lgamma(a + y) + lgamma(k + y) - lgamma(gama + y) - (lgamma(a + mu) + lgamma(k + mu) - lgamma(gama + mu))))\n      return(residuos)\n    }\n    if (type == 'response'){\n      residuos <- sort(object$residuals)\n      return(residuos)\n    }\n  }\n\n  if (envelope == FALSE) return(resid.gw(object, type))\n\n  else{\n    st <- proc.time()\n\n    k <- object$betaIIpars[1]\n    ro <- object$betaIIpars[2]\n    mu <- object$fitted.values\n    a <- mu * (ro - 1) / k\n\n    n<-sum(object$W)\n\n    if (parallel){\n      cl <- makeCluster(ncores)\n      registerDoParallel(cl)\n      clusterExport(cl, list(\"object\",\"rgw\",\"type\"),\n                    envir=environment())\n\n      residuos.sim <- foreach(j=1:(rep-1), .combine = cbind,.multicombine = TRUE,.inorder=FALSE,.packages=c(\"GWRM\"),.verbose=as.logical(trace)) %dopar%{\n        converged<-FALSE\n        varResponse<-getResponse(object$formula)\n        datos <- object$data[rep(1:nrow(object$data), object$W),]\n        datos[varResponse]<-as.matrix(rgw(n, a, k, ro))\n        while(!converged){\n          fit <- try(GWRM::gw(object$formula, data = datos, k = object$k, method = object$methodCode), silent = TRUE)\n          if(fit$aic>0)\n            converged<-TRUE\n          else{ ##Generate new response values\n            datos[varResponse]<-as.matrix(rgw(n, a, k, ro))\n          }\n        }\n        as.matrix(resid.gw(fit,type))\n      }\n      stopCluster(cl)\n    }else{\n      residuos.sim <- foreach(j=1:(rep-1), .combine = cbind,.multicombine = TRUE,.inorder=FALSE,.packages=c(\"GWRM\"),.verbose=as.logical(trace)) %do%{\n        converged<-FALSE\n        varResponse<-getResponse(object$formula)\n        datos <- object$data[rep(1:nrow(object$data), object$W),]\n        datos[varResponse]<-as.matrix(rgw(n, a, k, ro))\n        while(!converged){\n          fit <- try(GWRM::gw(object$formula, data = datos, k = object$k, method = object$methodCode), silent = TRUE)\n          if(fit$aic>0)\n            converged<-TRUE\n          else{ ##Generate new response values\n            datos[varResponse]<-as.matrix(rgw(n, a, k, ro))\n          }\n        }\n        as.matrix(resid.gw(fit,type))\n      }\n    }\n    residuos <- resid.gw(object, type)\n    residuos.sim<-cbind(as.matrix(rep(residuos,object$W)),residuos.sim)\n\n\n    minimos <- apply(residuos.sim[, 2:rep], 1, min)\n    maximos <- apply(residuos.sim[, 2:rep], 1, max)\n\n    t <- 1:n\n    normal.score <- qnorm(t / (n + 1))\n    xx <- c(normal.score, rev(normal.score))\n    yy <- c(minimos, rev(maximos))\n    plot(normal.score, residuos, type = \"l\", xlab = \"Standard normal quantiles\", ylab = paste(\"Residuals \",\"(\",type[1],\")\", sep = \"\"), main = title)\n    polygon(xx, yy, col = \"gray\", border = NA)\n    lines(normal.score, residuos)\n  }\n\n  et <- proc.time()\n  if (trace > 0)\n    cat(paste(\"\\nOverall envelope simulation process took\", round((et - st)[3], 2), 'seconds'))\n  else cat(\"\\n\")\n\n  ans <-  list(type = type, residuals = residuos, sim.residuals = residuos.sim)\n  class(ans) <- \"residuals.gw\"\n  return(ans)\n}\n",
    "created" : 1437685030451.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2949904970",
    "id" : "F751185C",
    "lastKnownWriteTime" : 1437687648,
    "path" : "E:/glm.wa/GWRM_DIVIDIDO_ROXYGEN/R/residuals.R",
    "project_path" : "R/residuals.R",
    "properties" : {
    },
    "relative_order" : 11,
    "source_on_save" : false,
    "type" : "r_source"
}