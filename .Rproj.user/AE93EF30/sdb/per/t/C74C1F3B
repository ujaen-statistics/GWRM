{
    "contents" : "#' Add All Possible Single Terms to a GWRM Model\n#'\n#' Compute all the single terms in the scope argument that can be added to the GWRM model, fit those models and compute a table of the changes in fit.\n#'\n#' @param object\ta fitted object of class inheriting from \"gw\".\n#' @param scope a formula giving the terms to be considered for adding.\n#' @param test \"none\", which considers the AIC criterion, or Chisq, which is the likelihood-ratio test.\n#' @param k the penalty constant in AIC / Cp.\n#' @param trace\tif TRUE, print out progress reports.\n#' @param ...\tfurther arguments passed to or from other methods.\n#'\n#' @return An object of class \"anova\" summarizing the differences in fit between the models.\n#'\n#' @importFrom stats pchisq add.scope update.formula extractAIC nobs formula update as.formula\n#' @examples\n#' data(goals)\n#' fit0 <- gw(goals ~ offset(log(played)), data = goals)\n#' summary(fit0)\n#'\n#' fit1 <- add1(fit0, ~ position)\n#' summary(fit1)\n#'\n#' @export\nadd1.gw <- function (object, scope, test = c(\"none\", \"Chisq\"), k = 2, trace = FALSE, ...) {\n\n  safe_pchisq <- function(q, df, ...){\n    df[df <= 0] <- NA\n    pchisq(q = q, df = df, ...)\n  }\n\n  if (missing(scope) || is.null(scope))\n    stop(\"no terms in scope\")\n  if (!is.character(scope))\n    scope <- add.scope(object, update.formula(object, scope))\n  if (!length(scope))\n    stop(\"no terms in scope for adding to object\")\n  ns <- length(scope)\n  ans <- matrix(nrow = ns + 1L, ncol = 2L, dimnames = list(c(\"<none>\", scope), c(\"df\", \"AIC\")))\n  ans[1L, ] <- extractAIC(object, k = k, ...)\n  n0 <- nobs(object, use.fallback = TRUE)\n  env <- environment(formula(object))\n  for (i in seq(ns)) {\n    tt <- scope[i]\n    if (trace > 0) {\n      cat(\"trying +\", tt, \"\\n\", sep = \"\")\n      utils::flush.console()\n    }\n    nfit <- update(object, as.formula(paste(\"~ . +\", tt)), evaluate = FALSE)\n    nfit <- eval(nfit, envir = env)\n    ans[i + 1L, ] <- extractAIC(nfit, k = k, ...)\n    nnew <- nobs(nfit, use.fallback = TRUE)\n    if (all(is.finite(c(n0, nnew))) && nnew != n0)\n      stop(\"number of rows in use has changed: remove missing values?\")\n  }\n  dfs <- ans[, 1L] - ans[1L, 1L]\n  dfs[1L] <- NA\n  aod <- data.frame(Df = dfs, AIC = ans[, 2L])\n  test <- match.arg(test)\n  if (test == \"Chisq\") {\n    dev <- ans[, 2L] - k * ans[, 1L]\n    dev <- dev[1L] - dev\n    dev[1L] <- NA\n    nas <- !is.na(dev)\n    P <- dev\n    P[nas] <- safe_pchisq(dev[nas], dfs[nas], lower.tail = FALSE)\n    aod[, c(\"LRT\", \"Pr(>Chi)\")] <- list(dev, P)\n  }\n  head <- c(\"Single term additions\", \"\\nModel:\", deparse(formula(object)))\n  class(aod) <- c(\"anova\", \"data.frame\")\n  attr(aod, \"heading\") <- head\n  aod\n}\n\n\n#' Drop All Possible Single Terms to a GWRM Model\n#'\n#' Compute all the single terms in the scope argument that can be dropped from the GWRM model, fit those models and compute a table of the changes in fit.\n#'\n#' @param object\ta fitted object of class inheriting from \"gw\".\n#' @param scope a formula giving the terms to be considered for dropping.\n#' @param test \"none\", which considers the AIC criterion, or Chisq, which is the likelihood-ratio test.\n#' @param k the penalty constant in AIC / Cp.\n#' @param trace\tif TRUE, print out progress reports.\n#' @param ...\tfurther arguments passed to or from other methods.\n#'\n#' @return An object of class \"anova\" summarizing the differences in fit between the models.\n#'\n#' @importFrom stats pchisq terms drop.scope update.formula extractAIC nobs formula update as.formula\n#'\n#' @examples\n#' data(goals)\n#'\n#' fit0 <- gw(goals ~ offset(log(played)), data = goals)\n#' summary(fit0)\n#'\n#' fit1 <- step(fit0, ~ position)\n#' summary(fit1)\n\n#'\n#' @export\n\ndrop1.gw<-function (object, scope, test = c(\"none\", \"Chisq\"), k = 2, trace = FALSE, ...) {\n\n  safe_pchisq <- function(q, df, ...){\n    df[df <= 0] <- NA\n    pchisq(q = q, df = df, ...)\n  }\n\n  tl <- attr(terms(object), \"term.labels\")\n  if (missing(scope))\n    scope <- drop.scope(object)\n  else {\n    if (!is.character(scope))\n      scope <- attr(terms(update.formula(object, scope)), \"term.labels\")\n    if (!all(match(scope, tl, 0L) > 0L))\n      stop(\"scope is not a subset of term labels\")\n  }\n  ns <- length(scope)\n  ans <- matrix(nrow = ns + 1L, ncol = 2L, dimnames = list(c(\"<none>\", scope), c(\"df\", \"AIC\")))\n  ans[1, ] <- extractAIC(object, k = k, ...)\n  n0 <- nobs(object, use.fallback = TRUE)\n  env <- environment(formula(object))\n  for (i in seq(ns)) {\n    tt <- scope[i]\n    if (trace > 0) {\n      cat(\"trying -\", tt, \"\\n\", sep = \"\")\n      utils::flush.console()\n    }\n    nfit <- update(object, as.formula(paste(\"~ . -\", tt)), evaluate = FALSE)\n    nfit <- eval(nfit, envir = env)\n    ans[i + 1, ] <- extractAIC(nfit, k = k, ...)\n    nnew <- nobs(nfit, use.fallback = TRUE)\n    if (all(is.finite(c(n0, nnew))) && nnew != n0)\n      stop(\"number of rows in use has changed: remove missing values?\")\n  }\n  dfs <- ans[1L, 1L] - ans[, 1L]\n  dfs[1L] <- NA\n  aod <- data.frame(Df = dfs, AIC = ans[, 2])\n  test <- match.arg(test)\n  if (test == \"Chisq\") {\n    dev <- ans[, 2L] - k * ans[, 1L]\n    dev <- dev - dev[1L]\n    dev[1L] <- NA\n    nas <- !is.na(dev)\n    P <- dev\n    P[nas] <- safe_pchisq(dev[nas], dfs[nas], lower.tail = FALSE)\n    aod[, c(\"LRT\", \"Pr(>Chi)\")] <- list(dev, P)\n  }\n  head <- c(\"Single term deletions\", \"\\nModel:\", deparse(formula(object)))\n  class(aod) <- c(\"anova\", \"data.frame\")\n  attr(aod, \"heading\") <- head\n  aod\n}\n\n#' Extract AIC\n#'\n#' Computes the (generalized) Akaike An Information Criterion for a fitted parametric model.\n#'\n#' @param fit\tfitted model, usually the result of a fitter like lm.\n#' @param scale\toptional numeric specifying the scale parameter of the model, see scale in step. Currently only used in the \"lm\" method, where scale specifies the estimate of the error variance, and scale = 0 indicates that it is to be estimated by maximum likelihood.\n#' @param k\tnumeric specifying the 'weight' of the equivalent degrees of freedom (=: edf) part in the AIC formula.\n#' @param ...\tfurther arguments (currently unused in base R).\n#'\n#' @examples\n#' fit<-gw(goals~played,data=goals)\n#' extractAIC(fit)\n#'\n#' @export\n\n\nextractAIC.gw <- function (fit, scale, k = 2, ...){\n  if (fit$aic < 0 || (fit$method != \"nlm\" && fit$code != 0)){\n    c(Inf, Inf)\n  }\n  else{\n    n <- length(fit$residuals)\n    edf <- n - fit$df.residual\n    aic <- fit$aic\n    c(edf, aic + (k - 2) * edf)\n  }\n}\n",
    "created" : 1437682303984.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2000999011",
    "id" : "C74C1F3B",
    "lastKnownWriteTime" : 1437682522,
    "path" : "E:/glm.wa/GWRM_DIVIDIDO_ROXYGEN/R/add.R",
    "project_path" : "R/add.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_source"
}