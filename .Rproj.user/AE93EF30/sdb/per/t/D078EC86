{
    "contents" : "#' Partition of the variance in a GWRM model\n#'\n#' In a GWRM model, the variance may be split into three terms. The first component of this decomposition represents the variability due to randomness and it comes from the underlying Poisson model. The other two components refer to the variability that is not due to randomness but is explained by the presence of liability and proneness, respectively.\n#'\n#' @param object\tan object class \"gw\" for which the partition is desired.\n#' @param newdata\toptionally, a data frame in which to look for variables with which to obtain the partition. If omitted, all the cases are used.\n#' @param ... \tfurther arguments passed to or from other methods.\n#'\n#' @return Two data frames, with ratio of sources of variation and sources of variation in which variance is splitted.\n#'\n#' @examples\n#'\n#' data(goals)\n#' fit <- gw(goals ~ position, data = goals)\n#' pos <- factor(c(\"Defender\", \"Midfielder\"), levels = c(\"Defender\", \"Midfielder\", \"Forward\"))\n#' lev <- data.frame(position = pos, played = c(17, 21))\n#'\n#' partvar(fit, newdata = lev)\n#'\n#' @export\n\npartvar <- function(object, newdata = NULL, ...){\n  UseMethod(\"partvar\",object)\n}\n\n\n#' partvar gw object.\n#'\n#' partvar gw object\n#'\n\n#' @param object\tan object class \"gw\" for which the partition is desired.\n#' @param newdata\toptionally, a data frame in which to look for variables with which to obtain the partition. If omitted, all the cases are used.\n#' @param ... \tfurther arguments passed to or from other methods.\n#' @importFrom stats delete.response .checkMFClasses\n#' @export\n\npartvar.gw <- function(object, newdata = NULL, ...){\n  tt <- terms(object)\n  if (!inherits(object, \"gw\"))\n    warning(\"calling predict.gw(<fake-gw-object>) ...\")\n\n  if (missing(newdata) || is.null(newdata)) {\n    mm <- X <- model.matrix(object)\n    mmDone <- TRUE\n    offset <- object$offset\n  }\n  else {\n    Terms <- delete.response(tt)\n    m <- model.frame(Terms, newdata, xlev = object$xlevels)\n    if (!is.null(cl <- attr(Terms, \"dataClasses\")))\n      .checkMFClasses(cl, m)\n    nobs<-nrow(as.matrix(m))\n    X <- model.matrix(Terms, m, offset <- rep(0, nobs))\n    if (!is.null(off.num <- attr(tt, \"offset\")))\n      for (i in off.num) offset <- offset + eval(attr(tt, \"variables\")[[i + 1]], newdata)\n    if (!is.null(object$call$offset))\n      offset <- offset + eval(object$call$offset, newdata)\n    mmDone <- FALSE\n  }\n\n  ncovars <- ncol(X)\n  beta <- object$coefficients[1:(ncovars)]\n  if(!object$kBool){\n    k <- object$betaIIpars[1]\n    ro <- object$betaIIpars[2]\n  }\n  else{\n    k <- object$k\n    ro <- object$betaIIpars[2]\n  }\n\n\n  if (is.null(offset)){\n    mus <- exp( X %*% beta)\n  }\n  else{\n    mus <- exp(offset +X %*% beta)\n  }\n\n  a <- mus * (ro - 1) / k\n  var <- mus * ((a + ro - 1) * (k + ro - 1)) / ((ro - 1) * (ro - 2))\n  prand <- mus / var\n  pliabi <- ((ro - 1) * (k + 1)) / ((a + ro - 1) * (k + ro - 1))\n  pprone <- a / (a + ro - 1)\n  rand <- mus\n  liabi <- pliabi * var\n  prone <- pprone * var\n  partvar_rate = data.frame(Levels = X, Randomness = prand, Liability = pliabi, Proneness = pprone)\n  partvar = data.frame(Levels = X, Randomness = rand, Liability = liabi, Proneness = prone)\n\n  ans <- list(Prop.Variance.Components = partvar_rate[, c(\"Randomness\", \"Liability\", \"Proneness\")], Variance.Components = partvar[, c(\"Randomness\", \"Liability\", \"Proneness\")])\n  return(ans)\n}\n",
    "created" : 1437684755025.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3757732744",
    "id" : "D078EC86",
    "lastKnownWriteTime" : 1437684816,
    "path" : "E:/glm.wa/GWRM_DIVIDIDO_ROXYGEN/R/partvar.R",
    "project_path" : "R/partvar.R",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "type" : "r_source"
}