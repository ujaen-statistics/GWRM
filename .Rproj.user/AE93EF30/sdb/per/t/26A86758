{
    "contents" : "#' Genaralizing Waring Regression\n#'\n#' Make a Genaralizing Waring Regression from a formula an a dataset extracting\n#' the response variable and de covariates in no method.... and call to\n#'\n#' @param formula\tan object of class \"formula\" (or one that can be coerced to that class): a symbolic description of the model to be fitted.\n#' @param data\tan optional data frame, list or environment (or object coercible by as.data.frame to a data frame) containing the variables in the model. If not found in data, the variables are taken from environment(formula).\n#' @param weights\tan optional vector of 'prior weights' to be used in the fitting process. Should be NULL or a numeric vector.\n#' @param k\toptional value for the k parameter. If NULL, it is estimated.\n#' @param subset\tan optional vector specifying a subset of observations to be used in the fitting process.\n#' @param na.action\ta function which indicates what should happen when the data contain NAs. See glm.\n#' @param kstart\tstarting value for the k parameter.\n#' @param rostart\tstarting value for the ro parameter.\n#' @param betastart\tstarting values for the vector of means.\n#' @param offset\tthis can be used to specify an a priori known component to be included in the linear predictor during fitting. This should be NULL or a numeric vector of length equal to the number of cases. One or more offset terms can be included in the formula instead or as well, and if more than one is specified their sum is used. See model.offset.\n#' @param control\ta list of parameters for controlling the fitting process.\n#' @param method\tthe method to be used in fitting the model. The default method initially uses non-linear minimization (nlm) and Nelder-Mead optimization (optim) to fit a model which is then re-fitted by \"L-BFGS-B\" (optim). In this way, SE estimates for all the model parameters are provided. \"nlm\" and \"Nelder-Mead\" are also possible values, but they do not provide SE estimates for k and ro.\n#' @param hessian\tif TRUE, the hessian of f at the minimum is returned.\n#' @param model\ta logical value indicating whether model frame should be included as a component of the returned value.\n#' @param x,y  logical values indicating whether the response vector and model matrix used in the fitting process should be returned as components of the returned value.\n#' @param ...\tfurther arguments.\n#'\n#' @return gw object\n#'\n#' @importFrom stats model.response is.empty.model model.matrix contrasts model.weights model.offset AIC .getXlevels\n#'\n#' @examples\n#' gw(goals~played+position,data=goals)\n#'\n#' @export\n\ngw <- function(formula, data, weights, k = NULL, subset, na.action,\n               kstart = 1, rostart = 2, betastart = NULL,offset, control = list(...), method = NULL, hessian = TRUE, model = TRUE, x = FALSE, y = TRUE, ...){\n\n  warningDefault<-getOption(\"warn\")\n\n  if (is.null(control$trace)){\n    control$trace = 0\n  }\n\n  if (control$trace== 0)\n    options(warn=-1)\n\n  call <- match.call()\n  if (missing(data))\n    data <- environment(formula)\n  mf <- match.call(expand.dots = FALSE)\n  m <- match(c(\"formula\", \"data\", \"subset\", \"weights\", \"na.action\",\"offset\"), names(mf), 0L)\n  mf <- mf[c(1L, m)]\n  mf$drop.unused.levels <- TRUE\n  mf[[1L]] <- as.name(\"model.frame\")\n  mf <- eval.parent(mf)\n\n  fitted<-FALSE\n\n  Terms <- attr(mf, \"terms\")\n  Y <- model.response(mf, \"any\")\n  nobs<-nrow(as.matrix(Y))\n  X <- if(!is.empty.model(Terms)){\n    model.matrix(Terms, mf, contrasts)\n  }\n  else{\n    matrix(1, nobs, 0)\n  }\n  weights <- as.vector(model.weights(mf))\n  if (!is.null(weights) && !is.numeric(weights))\n    stop(\"'weights' must be a numeric vector\")\n  if (!is.null(weights) && any(weights < 0))\n    stop(\"negative weights not allowed\")\n  offset <- as.vector(model.offset(mf))\n\n  if (!is.null(offset)) {\n    if (length(offset) != nobs)\n      stop(gettextf(\"Number of offsets is %d should equal %d (number of observations)\", length(offset), nobs), domain = NA)\n  }\n  if (is.null(method)){\n    if (control$trace > 0) {\n      cat(\"Trying 'nlm' initial fit\", \"\\n\")\n    }\n    nlm.fit <-try(eval(gw.fit(x = X, y = Y, weights = weights, k = k, kstart = kstart, rostart = rostart, betastart = betastart, offset = offset, control = control, method = \"nlm\", hessian = hessian)), silent = TRUE)\n    if ('try-error' %in% class(nlm.fit)){\n      if (control$trace > 0) {\n        cat(\"Crashed 'nlm' initial fit\", \"\\n\")\n      }\n      nlm.aic <- Inf\n    }\n    else {\n      nlm.aic <- AIC(nlm.fit)\n      if (control$trace > 0) {\n        cat(paste(round(nlm.aic, 2), \"AIC value in 'nlm' initial fit\"), \"\\n\")\n      }\n    }\n    if (control$trace > 0) {\n      cat(\"Trying 'Nelder-Mead' initial fit\", \"\\n\")\n    }\n    neldermead.fit <- try(eval(gw.fit(x = X, y = Y, weights = weights, k = k, kstart = kstart, rostart = rostart, betastart = betastart, offset = offset, control = control, method = \"Nelder-Mead\", hessian = hessian)), silent = TRUE)\n\n    if ('try-error' %in% class(neldermead.fit)){\n      if (control$trace > 0) {\n        cat(\"Crashed 'Nelder-Mead' initial fit\", \"\\n\")\n      }\n      neldermead.aic <- Inf\n    }\n    else {\n      neldermead.aic <- AIC(neldermead.fit)\n      if (control$trace > 0) {\n        cat(paste(round(neldermead.aic,2), \"AIC value in 'Nelder-Mead' initial fit\"), \"\\n\")\n      }\n    }\n    if (neldermead.aic == Inf & nlm.aic == Inf){\n      warning(\"No 'nlm' neither 'Nelder-Mead' provide fits. Try to change initial values\")\n    }\n    else {\n      if (neldermead.aic < nlm.aic | nlm.aic <= 0){\n        fit2 <- neldermead.fit\n      }\n      else{\n        fit2<-nlm.fit\n      }\n      if (control$trace > 0) {\n        cat(\"L-BFGS-B fitting\",\"\\n\")\n      }\n      fit <- try(eval(gw.fit(x = X, y = Y, weights = weights, k = k, kstart = fit2$betaIIpars[1], rostart = fit2$betaIIpars[2], betastart = fit2$betascoefs, offset=offset, control = control, method = \"L-BFGS-B\", hessian = hessian)),silent=TRUE)\n      if ('try-error' %in% class(fit)){\n        if (control$trace > 0) {\n          cat(\"Crashed 'L-BFGS-B' final fit\", \"\\n\")\n        }\n        fit <- fit2\n      }\n\n      fitted <- TRUE\n\n    }\n  }\n  else{\n    if (!any(method == c(\"nlm\", \"Nelder-Mead\", \"BFGS\", \"CG\", \"L-BFGS-B\", \"SANN\"))){\n      stop(\"method must be in c('nlm', 'Nelder-Mead', 'BFGS', 'CG', 'L-BFGS-B', 'SANN')\")\n    }\n    else{\n      fit <- try(eval(gw.fit(x = X, y = Y, weights = weights,offset=offset, k = k, kstart = kstart, rostart = rostart, betastart = betastart, control = control, method = method, hessian = hessian)), silent = TRUE)\n      if ('try-error' %in% class(fit)){\n        warning(\"Crashed fit\", \"\\n\")\n      }\n      else{\n        fitted<-TRUE\n      }\n    }\n  }\n  if (fitted){\n    if (x)\n      fit$X <- X\n    if (!y)\n      fit$Y <- NULL\n    fit <- c(fit, list(call = call, formula = formula, terms = Terms, data = data, offset = offset, control = control, method = method, contrasts = attr(X, \"contrasts\"), xlevels = .getXlevels(Terms, mf)))\n    class(fit) <- \"gw\"\n  }\n  else{\n    fit$aic<- -Inf\n  }\n  options(warn=warningDefault)\n  fit\n\n}\n\n\n\n#' Genaralizing Waring Regression\n#'\n#' Make a Genaralizing Waring Regression from a formula an a dataset extracting\n#' the response variable and de covariates in no method.... and call to\n#' gw.fit\n#'\n#' @param x  vector of covariables\n#' @param y vector of response variables\n#' @param weights weights of de data is exists\n#' @param k\toptional value for the k parameter. If NULL, it is estimated.\n#' @param kstart\tstarting value for the k parameter.\n#' @param rostart\tstarting value for the ro parameter.\n#' @param betastart\tstarting values for the vector of means.\n#' @param offset\tthis can be used to specify an a priori known component to be included in the linear predictor during fitting. This should be NULL or a numeric vector of length equal to the number of cases. One or more offset terms can be included in the formula instead or as well, and if more than one is specified their sum is used. See model.offset.\n#' @param control\ta list of parameters for controlling the fitting process.\n#' @param method\tthe method to be used in fitting the model. The default method initially uses non-linear minimization (nlm) and Nelder-Mead optimization (optim) to fit a model which is then re-fitted by \"L-BFGS-B\" (optim). In this way, SE estimates for all the model parameters are provided. \"nlm\" and \"Nelder-Mead\" are also possible values, but they do not provide SE estimates for k and ro.\n#' @param hessian\tif TRUE, the hessian of f at the minimum is returned.\n#' @param intercept\ta logical value ...\n#' @param ...\tfurther arguments.\n#'\n#' @return gw object\n#'\n#' @importFrom stats nlm optim\n#'\n#' @examples\n#' gw(goals~played+position,data=goals)\n#'\n#' @export\n\ngw.fit <-function (x, y, weights = NULL, k = NULL, kstart = 1, rostart = 2, betastart = NULL, offset = NULL, control = list(), method = \"L-BFGS-B\", hessian=TRUE, intercept = TRUE){\n\n  control <- do.call(\"gw.control\", control)\n  X <- x\n  xnames<-dimnames(X)[[2L]]\n  Y <- y\n  conv <- FALSE\n  nobs <- nrow(as.matrix(X))\n  ncovars <- ncol(as.matrix(X))\n  if (is.null(weights))\n    w <- rep(1, nobs)\n  else{\n    w <- weights\n  }\n  if (is.null(offset)){\n    offset <- rep(0, nobs)\n    covoffset <- FALSE\n  }\n  else{\n    covoffset <- TRUE\n  }\n  if (is.null(kstart))\n    kstart <- 1\n  if (is.null(rostart))\n    rostart <- 2\n  if(!is.null(k)){\n    kBool <- TRUE   #Boolean about k parameter\n    gCorrect <- 1   #To correct df, since there is a parameter less\n  }\n  else{\n    kBool <- FALSE\n    gCorrect <- 0\n  }\n\n  if (kstart <= 0){\n    stop(\"kstart must be positive\")\n  }\n\n  if (rostart <= 1){\n    stop(\"rostart must be greater than 1\")\n  }\n\n  if (!is.logical(hessian)){\n    stop(\"Hessian must be logical\")\n  }\n\n  if (!any(method == c(\"nlm\", \"Nelder-Mead\", \"BFGS\", \"CG\", \"L-BFGS-B\", \"SANN\"))){\n    stop(\"method must be in c('nlm', 'Nelder-Mead', 'BFGS', 'CG', 'L-BFGS-B', 'SANN')\")\n  }\n\n  if (is.null(betastart)){\n    betastart <- rep(0, ncovars)\n  }\n\n  #Log-likelihood and initial value\n  if(!kBool){\n    logL<-function(p){\n      beta <- p[1:(ncovars)]\n      betak <- p[ncovars + 1]\n      betaro <- p[ncovars + 2]\n      if (method != \"L-BFGS-B\"){\n        k <- exp(betak)\n        ro <- 1 + exp(betaro)\n      }\n      else{\n        k <- betak\n        ro <- betaro\n      }\n      mu <- exp(offset + X %*% beta)\n      a <- mu * (ro - 1) / k\n      gama <- a + k + ro\n      -sum(w * (lgamma(a + Y) - lgamma(a) + lgamma(k + Y) - lgamma(k) - lgamma(gama + Y) + lgamma(a + ro) + lgamma(k + ro) - lgamma(ro)))\n    }\n    if (method != \"L-BFGS-B\"){\n      p0 <- c(betastart, log(kstart), log(rostart - 1))\n    }\n    else{\n      p0 <- c(betastart, kstart, rostart)\n    }\n  }\n  else{\n    logL <- function(p){\n      beta <- p[1:(ncovars)]\n      betaro<-p[ncovars + 1]\n      if (method != \"L-BFGS-B\"){\n        ro <- 1 + exp(betaro)\n      }\n      else{\n        ro <- betaro\n      }\n      mu <- exp(offset + X %*% beta)\n      a <- mu * (ro - 1) / k\n      gama <- a + k + ro\n      #If k=1 there is a simpler expresion\n      if (k == 1){\n        -sum(w * (lbeta(a + Y, ro + 1) - lbeta(a, ro)))\n      }\n      else{\n        -sum(w * (lgamma(a + Y) - lgamma(a) + lgamma(k + Y) - lgamma(k) - lgamma(gama + Y) + lgamma(a + ro) + lgamma(k + ro) - lgamma(ro)))\n      }\n    }\n    if (method != \"L-BFGS-B\"){\n      p0 <- c(betastart, log(rostart - 1))\n    }\n    else{\n      p0 <- c(betastart, rostart)\n    }\n  }\n\n  #Optimizing log-likelihood\n  if (method == \"nlm\"){\n    fit <- nlm(logL, p = p0, hessian = hessian, iterlim = control$maxit, print.level = control$trace)\n    fit$value <- fit$minimum\n    fit$par <- fit$estimate\n    fit$convergence <- fit$code\n    methodText = \"nlm\"\n  }\n  else if (any(method == c(\"Nelder-Mead\", \"BFGS\", \"CG\",\"SANN\"))){\n    fit <- optim(p0, logL, method = method, hessian = hessian, control = list(maxit = control$maxit, trace = control$trace))\n    methodText <- method\n  }\n  else if (any(method == c(\"L-BFGS-B\"))){\n    #The constraints depends on whether k is known so\n    if(!kBool){\n      lower <- c(rep(-Inf, ncovars), 0.0000001, 1.0000001)\n    }\n    else{\n      lower <- c(rep(-Inf, ncovars), 1.0000001)\n    }\n    fit <- optim(p0, logL, method = method, hessian = hessian, lower = lower, control = list(maxit = control$maxit, trace = control$trace))\n    methodText <- method\n  }\n\n  if(!kBool){\n    if (any(method == c(\"nlm\", \"Nelder-Mead\", \"BFGS\", \"CG\",\"SANN\"))){\n      coef.table <- rbind(fit$par, deparse.level = 0)\n      dimnames(coef.table) <- list(\"\", c(xnames, \"log(k)\", \"log(ro-1)\"))\n      betaIIpars <- c(exp(fit$par[ncovars + 1]), 1 + exp(fit$par[ncovars + 2]))\n    }\n    else{\n      coef.table <- rbind(fit$par, deparse.level = 0)\n      dimnames(coef.table) <- list(\"\", c(xnames, \"k\", \"ro\"))\n      betaIIpars <- c(fit$par[ncovars + 1], fit$par[ncovars + 2])\n    }\n  }\n  else{\n    if (any(method == c(\"nlm\", \"Nelder-Mead\", \"BFGS\", \"CG\",\"SANN\"))){\n      coef.table <- rbind(fit$par, deparse.level = 0)\n      dimnames(coef.table) <- list(\"\", c(rep(\"beta\", ncovars), \"log(ro-1)\"))\n      dimnames(coef.table) <- list(\"\", c(xnames, \"log(ro-1)\"))\n      betaIIpars <- c(k, 1 + exp(fit$par[ncovars + 1]))\n    }\n    else{\n      coef.table <- rbind(fit$par, deparse.level = 0)\n      dimnames(coef.table) <- list(\"\", c(xnames, \"ro\"))\n      betaIIpars <- c(k, fit$par[ncovars + 1])\n    }\n  }\n\n\n  results <- list(\n    Y = Y,\n    W = w,\n    covars = dimnames(X)[[2]],\n    nobs = sum(w),\n    covoffset = covoffset,\n    loglik = -(fit$value + sum(w * lfactorial(Y))),\n    aic = 2 * (fit$value + sum(w * lfactorial(Y))) + (length(betastart) + 2 - gCorrect) * 2,\n    bic = 2 * (fit$value + sum(w * lfactorial(Y))) + (length(betastart) + 2 - gCorrect) * log(sum(w)),\n    df.residual = sum(w) - (length(betastart) + 2 - gCorrect),\n    residuals = Y - exp(offset + X %*% fit$par[1:ncovars]),\n    coefficients = coef.table,\n    betaIIpars = betaIIpars,\n    betascoefs = fit$par[1:ncovars],\n    fitted.values = exp(offset + X %*% fit$par[1:ncovars]),\n    hessian = fit$hessian,\n    cov = solve(fit$hessian),\n    se = sqrt(diag(solve(fit$hessian))),\n    corr = solve(fit$hessian) / (sqrt(diag(solve(fit$hessian))) %o% sqrt(diag(solve(fit$hessian)))),\n    code = fit$convergence,\n    method = methodText,\n    k = k,\n    kBool = kBool\n  )\n\n  class(results) <- \"gw\"\n  return(results)\n}\n\n\n#' Print a GWRM model\n#'\n#' Print a GWRM model\n#'\n#' @param x\tan object class \"gw\" for which the partition is desired.\n#' @param digits  number ob digit used\n#' @param ... \tfurther arguments passed to or from other methods.\n#'\n#' @return Sintesis de un objeto gw\n#'\n#' @importFrom stats coef naprint\n#'\n#' @examples\n#'\n#' data(goals)\n#' fit <- gw(goals ~ position, data = goals)\n#' print(fit)\n#'\n#' @export\n#'\nprint.gw<-function (x, digits = max(3L, getOption(\"digits\") - 3L), ...) {\n  cat(\"\\nCall:  \", paste(deparse(x$call), sep = \"\\n\", collapse = \"\\n\"), \"\\n\\n\", sep = \"\")\n  if (length(coef(x))) {\n    cat(\"Coefficients\")\n    if (is.character(co <- x$contrasts)) {\n      cat(\"  [contrasts: \", apply(cbind(names(co), co), 1L, paste, collapse = \"=\"), \"]\")\n    }\n    cat(\":\\n\")\n    print.default(format(x$coefficients, digits = digits), print.gap = 2, quote = FALSE)\n  }\n  else cat(\"No coefficients\\n\\n\")\n\n  cat(\"\\nDegrees of Freedom:\", x$df.residual, \"Residual\\n\")\n  if (nzchar(mess <- naprint(x$na.action))) {\n    cat(\"  (\", mess, \")\\n\", sep = \"\")\n  }\n  cat(\"AIC:\", format(signif(x$aic, digits)))\n  cat(\"\\n\")\n  invisible(x)\n}\n\n#' Summarizing GWRM model Fits\n#'\n#' summary method for class \"gw\".\n#' @param object an object of class \"gw\", usually, a result of a call to gw\n#' @param ... \tfurther arguments passed to or from other methods.\n#'\n#' @return Sintesis de un objeto gw\n#'\n#' @importFrom stats pnorm\n#'\n#' @examples\n#'\n#' data(goals)\n#' fit <- gw(goals ~ position, data = goals)\n#' summary(fit)\n#'\n#' @export\nsummary.gw <- function (object, ...){\n\n  df.r <- object$df.residual\n  if (is.null(object$covars)) object$covars <- \"(Intercept)\"\n  coef.p <- object$betascoefs\n  s.err <- object$se[1:length(object$betascoefs)]\n  tvalue <- (object$betascoefs) / (object$se[1:length(object$betascoefs)])\n  pvalue <- 2 * pnorm(abs((object$betascoefs) / (object$se[1:length(object$betascoefs)])), lower.tail = FALSE)\n  dn <- c(\"Estimate\", \"Std. Error\")\n  coef.table <- cbind(coef.p, s.err, tvalue, pvalue)\n  dimnames(coef.table) <- list(object$covars, c(dn, \"z value\", \"Pr(>|z|)\"))\n  fitted <- cbind(object$loglik, object$aic, object$bic, object$df)\n  dimnames(fitted) <- list(\"\", c(\"log-likelihood\", \"AIC\", \"BIC\", \"df\"))\n  if (!object$kBool){\n    if (any(object$method == c(\"nlm\", \"Nelder-Mead\", \"BFGS\", \"CG\",\"SANN\"))){\n      coefk <- object$coefficients[length(object$betascoefs) + 1]\n      coefro <- object$coefficients[length(object$betascoefs) + 2]\n      k <- object$betaIIpars[1]\n      ro <- object$betaIIpars[2]\n      #Std. error aproximated by delta method\n      SE.k <- object$se[length(object$betascoefs) + 1] * exp(coefk)\n      SE.ro <- object$se[length(object$betascoefs) + 2] * exp(coefro)\n      betaII <- cbind(c(\"k\", \"ro\"), format(c(k, ro)), format(c(SE.k, SE.ro)))\n      dimnames(betaII) <- list(c(\"\",\"\"), c(\"par\", \"Estimate\", \"Std. Error (Delta method)\"))\n    }\n    else{\n      k <- object$betaIIpars[1]\n      ro <- object$betaIIpars[2]\n      SE.k <- object$se[length(object$betascoefs) + 1]\n      SE.ro <- object$se[length(object$betascoefs) + 2]\n      betaII <- cbind(c(\"k\", \"ro\"), format(c(k, ro)), format(c(SE.k, SE.ro)))\n      dimnames(betaII) <- list(c(\"\", \"\"), c(\"par\", \"Estimate\", \"Std. Error\"))\n    }\n  }\n  else{\n    if (any(object$method == c(\"nlm\", \"Nelder-Mead\", \"BFGS\", \"CG\",\"SANN\"))){\n      coefro <- object$coefficients[length(object$betascoefs) + 1]\n      k <- 1\n      ro <- object$betaIIpars[2]\n      #Std. Error aproximated by delta method\n      SE.k <- NA\n      SE.ro <- object$se[length(object$betascoefs) + 1] * exp(coefro)\n      betaII <- cbind(c(\"k\", \"ro\"), format(c(k, ro)), format(c(SE.k, SE.ro)))\n      dimnames(betaII) <- list(c(\"\",\"\"), c(\"par\", \"Estimate\", \"Std. Error\"))\n    }\n    else{\n      k <- 1\n      ro <- object$betaIIpars[2]\n      SE.k <- NA\n      SE.ro <- object$se[length(object$betascoefs) + 1]\n      betaII <- cbind(c(\"k\", \"ro\"), format(c(k, ro)), format(c(SE.k, SE.ro)))\n      dimnames(betaII) <- list(c(\"\",\"\"), c(\"par\", \"Estimate\", \"Std. Error\"))\n    }\n  }\n\n  keep <- match(c(\"call\", \"terms\", \"deviance\", \"aic\", \"contrasts\", \"df.residual\", \"na.action\"), names(object), 0L)\n  ans <- c(object[keep], list(coefficients = coef.table, fitted = fitted, betaII = betaII, method = object$method, convergence = object$code))\n  class(ans) <- \"summary.gw\"\n  return(ans)\n}\n\n#' Print Summarizing GWRM model Fits\n#'\n#' print summary class for summary class \"gw\".\n#' @param x\tan object class \"summary.gw\" for which the partition is desired.\n#' @param digits  number ob digit used\n#' @param ... \tfurther arguments passed to or from other methods.\n#'\n#' @importFrom stats coef naprint\n#'\n#' @export\n#'\nprint.summary.gw <- function (x, digits = max(3, getOption(\"digits\") - 3), ...){\n  if (!inherits(x, \"summary.gw\"))\n  stop(\"'x' must inherit from class %s\", dQuote(\"summary.table\"), domain = NA)\n\n  cat(\"\\nCall:  \", paste(deparse(x$call), sep = \"\\n\", collapse = \"\\n\"), \"\\n\\n\", sep = \"\")\n  if (length(coef(x))){\n    cat(\"Coefficients\")\n    if (is.character(co <- x$contrasts)){\n      cat(\"  [contrasts: \", apply(cbind(names(co), co), 1L, paste, collapse = \"=\"), \"]\")\n    }\n    cat(\":\\n\")\n    print.default(format(x$coefficients, digits = digits), print.gap = 2, quote = FALSE)\n  }\n  else cat(\"No coefficients\\n\\n\")\n  if (length(x$fitted)){\n    cat(\"\\n\")\n    cat(\"Fit:\\n\")\n    print.default(format(x$fitted, digits = digits), print.gap = 2, quote = FALSE)\n  }\n  else cat(\"No fits\\n\\n\")\n  if (length(x$betaII)){\n    cat(\"\\n\")\n    cat(\"betaII:\\n\")\n    print.default(format(x$betaII, digits = digits), print.gap = 2, quote = FALSE)\n  }\n  else cat(\"No betaII\\n\\n\")\n  cat(\"\\nDegrees of Freedom:\", x$df.null, \"Total (i.e. Null); \", x$df.residual, \"Residual\\n\")\n  cat(\"\\nCode of convergence:\", x$convergence, \"\\n\")\n  cat(\"\\nMethod:\", x$method, \"\\n\")\n  if (nzchar(mess <- naprint(x$na.action))){\n    cat(\"  (\", mess, \")\\n\", sep = \"\")\n  }\n  invisible(x)\n}\n\ngw.control <- function (maxit = 10000, epsilon = 1e-08, trace = FALSE) {\n  if (!is.numeric(epsilon) || epsilon <= 0)\n    stop(\"value of 'epsilon' must be > 0\")\n  if (!is.numeric(maxit) || maxit <= 0)\n    stop(\"maximum number of iterations must be > 0\")\n  list(epsilon = epsilon, maxit = maxit, trace = trace)\n}\n\n#' @importFrom stats model.frame\nmodel.matrix.gw<-function (object, ...) {\n  if (n_match <- match(\"x\", names(object), 0L)) object[[n_match]]\n  else {\n    data <- model.frame(object, xlev = object$xlevels, ...)\n    NextMethod(\"model.matrix\", data = data, contrasts.arg = object$contrasts)\n  }\n}\n\nmodel.frame.gw <- function (formula, ...) {\n  dots <- list(...)\n  nargs <- dots[match(c(\"data\", \"na.action\", \"subset\"), names(dots), 0)]\n  if (length(nargs) || is.null(formula$model)) {\n    fcall <- formula$call\n    m <- match(c(\"formula\", \"data\", \"subset\", \"weights\", \"na.action\", \"offset\"), names(fcall), 0L)\n    fcall <- fcall[c(1L, m)]\n    fcall$drop.unused.levels <- TRUE\n    fcall[[1L]] <- quote(stats::model.frame)\n    fcall$xlev <- formula$xlevels\n    fcall$formula <- terms(formula)\n    fcall[names(nargs)] <- nargs\n    env <- environment(formula$terms)\n    if (is.null(env))\n      env <- parent.frame()\n    eval(fcall, env, parent.frame())\n  }\n  else formula$model\n}\n\nformula.gw<-function (x, ...) {\n  form <- x$formula\n  if (!is.null(form)) {\n    form <- formula(x$terms)\n    environment(form) <- environment(x$formula)\n    form\n  }\n  else formula(x$terms)\n}\n",
    "created" : 1437682788277.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "892993182",
    "id" : "26A86758",
    "lastKnownWriteTime" : 1437684982,
    "path" : "E:/glm.wa/GWRM_DIVIDIDO_ROXYGEN/R/gw.r",
    "project_path" : "R/gw.r",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "type" : "r_source"
}